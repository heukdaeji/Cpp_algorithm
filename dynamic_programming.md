# 문제이름

[(문제번호)](https://www.acmicpc.net/problem/1000)

## 문제 접근
* ~~

* 알고리즘: ~\~, 자료구조: ~\~, 시간복잡도: ~\~

## 어려웠던 점
* ~~

## 해결 방법
* ~~

## 핵심 코드

* ~~

# 계단오르기

[(2579)](https://www.acmicpc.net/problem/2579)

## 문제 접근
* i번째 점수를 a\[i], i번째까지의 점수 총합을 d\[i], 1번 연속: d\[i]\[0], 2번 연속: d\[i][1]이라 하면,
* d\[i]\[0] = max(d\[i-2]\[0], d\[i-2]\[1]) + a\[i], d\[i]\[1] = d\[i-1]\[0] + a\[i];

* 알고리즘: ~\~, 자료구조: ~\~, 시간복잡도: ~\~

## 어려웠던 점
* ~~

## 해결 방법
* ~~

## 핵심 코드

``` cpp
    d[0][0] = d[0][1] = a[0];
    d[1][0] = a[0] + a[1];
    d[1][1] = a[1];
```
* 0번째 값과 1번째 값을 정해준다.
```cpp
    for (int i = 2; i < N; i++) {
        d[i][0] = d[i-1][1] + a[i];
        d[i][1] = max(d[i-2][0], d[i-2][1]) + a[i];
    }
```
* 각각의 1번 연속, 2번 연속 점수 총합을 구해준다.
## 소스 코드

```cpp
    #include <iostream>

    using namespace std;

    int a[301], d[301][2], N;

    int main() {
        cin >> N;
        for (int i = 0; i < N; i++) {
            cin >> a[i];
        }
        d[0][0] = d[0][1] = a[0];
        d[1][0] = a[0] + a[1];
        d[1][1] = a[1];
        for (int i = 2; i < N; i++) {
            d[i][0] = d[i-1][1] + a[i];
            d[i][1] = max(d[i-2][0], d[i-2][1]) + a[i];
        }
        cout << max(d[N-1][0], d[N-1][1]);
}
```
